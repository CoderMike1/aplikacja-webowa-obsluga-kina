# Generated by Django 5.2.7 on 2025-11-20 20:36

from django.db import migrations, models
from django.db.models import F
from datetime import timedelta


ALLOWED_MINUTES = [0, 10, 20, 30, 40, 50]
BUFFER_MINUTES = 30


def round_up_allowed(dt):
    """Round datetime up to next allowed minute (preserving hour/day) and zero seconds."""
    if dt.minute in ALLOWED_MINUTES and dt.second == 0 and dt.microsecond == 0:
        return dt.replace(second=0, microsecond=0)
    # find next allowed minute greater than current minute
    for m in ALLOWED_MINUTES:
        if m >= dt.minute:
            return dt.replace(minute=m, second=0, microsecond=0)
    # overflow to next hour at minute 0
    dt = dt.replace(minute=0, second=0, microsecond=0) + timedelta(hours=1)
    return dt


def floor_allowed(dt):
    """Floor datetime to allowed minute (<= original minute), zero seconds/micros."""
    for m in reversed(ALLOWED_MINUTES):
        if dt.minute >= m:
            return dt.replace(minute=m, second=0, microsecond=0)
    return dt.replace(minute=0, second=0, microsecond=0)


def fix_screenings_alignment(apps, schema_editor):
    Screening = apps.get_model('screenings', 'Screening')
    Movie = apps.get_model('movies', 'Movie')

    # Process per auditorium to maintain sequential buffering
    from collections import defaultdict
    by_auditorium = defaultdict(list)
    for s in Screening.objects.select_related('movie', 'auditorium').order_by('auditorium_id', 'start_time'):
        by_auditorium[s.auditorium_id].append(s)

    for auditorium_id, screenings in by_auditorium.items():
        prev_end = None
        occupied = set()  # track adjusted start_times to avoid duplicates
        for s in screenings:
            original_start = s.start_time
            movie = s.movie
            duration = getattr(movie, 'duration_minutes', 0) or 0

            # Adjust published_at if violates start_time >= published_at
            if s.start_time < s.published_at:
                s.published_at = s.start_time

            # Floor start to allowed grid first (not earlier than original floor)
            candidate = floor_allowed(original_start)

            # Enforce buffer after previous screening
            if prev_end is not None:
                min_allowed = prev_end + timedelta(minutes=BUFFER_MINUTES)
                if candidate < min_allowed:
                    candidate = round_up_allowed(min_allowed)

            # Ensure candidate not earlier than original floor (we never move backwards beyond floor)
            floor_orig = floor_allowed(original_start)
            if candidate < floor_orig:
                candidate = floor_orig

            # Resolve collisions on (auditorium, candidate)
            while candidate in occupied:
                candidate = round_up_allowed(candidate + timedelta(minutes=10))

            # Final normalization: ensure allowed minute & zero seconds
            candidate = round_up_allowed(candidate)
            while candidate in occupied:
                candidate = round_up_allowed(candidate + timedelta(minutes=10))

            # Persist changes if modified
            if candidate != s.start_time:
                s.start_time = candidate
            if s.start_time < s.published_at:
                s.published_at = s.start_time
            s.save(update_fields=['start_time', 'published_at'])

            occupied.add(s.start_time)
            prev_end = s.start_time + timedelta(minutes=duration)



class Migration(migrations.Migration):

    dependencies = [
        ('auditorium', '0001_initial'),
        ('movies', '0006_alter_movie_poster_path'),
        ('screenings', '0003_screening_published_at'),
    ]

    operations = [
        migrations.RunPython(fix_screenings_alignment, migrations.RunPython.noop),
        migrations.AddConstraint(
            model_name='screening',
            constraint=models.CheckConstraint(condition=models.Q(('start_time__gte', models.F('published_at'))), name='chk_start_time_gte_published_at'),
        ),
        migrations.AddConstraint(
            model_name='screening',
            constraint=models.CheckConstraint(condition=models.Q(('start_time__minute__in', [0, 10, 20, 30, 40, 50]), ('start_time__second', 0)), name='chk_start_time_minute_alignment'),
        ),
    ]
